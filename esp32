#Here we are going to import everything necesary to connect the ESP32
#to the internet, use the MQTT, and control the hardware.
import network, time, machine, ubinascii, json
from umqtt.simple import MQTTClient

# ========= CONFIG =========
WIFI_SSID = "YOUR_SSID"
WIFI_PASS = "YOUR_PASSWORD"
MQTT_HOST = "BROKER_HOST"
MQTT_PORT = 1883     # TCP without TLS
# MQTT_PORT = 8883   # with TLS 

USE_TLS = False
TOPIC_SUB = b"YOUR_MQTT_TOPIC"
CLIENT_PREFIX = b"esp32-"
KEEPALIVE = 30

LED_PIN = 2  
BLINK_TIMES = 5
ON_MS = 120
OFF_MS = 120
# =========================

led = machine.Pin(LED_PIN, machine.Pin.OUT)
led.off()

#define a debugging helper function
def log(*args):
    try:
        print("[DBG]", *args)
    except:
        pass

#define a WiFi connection function
def wifi_connect():
    sta = network.WLAN(network.STA_IF)
    if not sta.active():
        sta.active(True)
    if not sta.isconnected():
        log("Connectiong WiFi to:", WIFI_SSID)
        sta.connect(WIFI_SSID, WIFI_PASS)
        for i in range(80):
            if sta.isconnected():
                break
            time.sleep_ms(250)
            if i % 8 == 0:
                log("... waiting WiFi")
    if not sta.isconnected():
        raise RuntimeError("WiFi NO connected")
    log("WiFi OK:", sta.ifconfig())
    return sta

#define the function that makes the LED blink.
def blink(n=BLINK_TIMES, on=ON_MS, off=OFF_MS):
    for _ in range(n):
        led.on(); time.sleep_ms(on)
        led.off(); time.sleep_ms(off)

#define the function that turns the MQTT message into something our code can understand.
def parse_msg(msg):
    try:
        #If msg is a byte or bytearray, .decode() converts it into text; otherwise, it is converted with str(msg).
        s = msg.decode() if isinstance(msg, (bytes, bytearray)) else str(msg)
        s = s.strip()
        if s.lower() == "blink":
            return {"cmd": "blink"}
        return json.loads(s)
    except Exception as e:
        log("parse_msg EXC:", e)
        return {"cmd": "blink"}

def on_mqtt(topic, msg):
    log("MQTT RX topic=", topic, "msg=", msg)
    data = parse_msg(msg)
    if data.get("cmd") == "blink":
        t = int(data.get("times", BLINK_TIMES))
        on = int(data.get("on", ON_MS))
        off = int(data.get("off", OFF_MS))
        blink(t, on, off)

def make_client():
    cid = CLIENT_PREFIX + ubinascii.hexlify(machine.unique_id())
    log("ClientID:", cid)
    c = MQTTClient(client_id=cid,
                   server=MQTT_HOST,
                   port=MQTT_PORT,
                   keepalive=KEEPALIVE,
                   ssl=USE_TLS)
    c.set_callback(on_mqtt)
    try:
        c.set_last_will(b"%s/status" % cid, b"offline", retain=False, qos=0)
    except:
        pass
    return c

def mqtt_connect_and_subscribe(c):
    while True:
        try:
            log("Connecting MQTT:", MQTT_HOST, MQTT_PORT, "TLS" if USE_TLS else "noTLS")
            c.connect(clean_session=True)
            log("MQTT connected")
            c.subscribe(TOPIC_SUB, qos=0)
            log("Subscribed to:", TOPIC_SUB)
            try:
                c.publish(b"%s/status" % (CLIENT_PREFIX + ubinascii.hexlify(machine.unique_id())), b"online", retain=False, qos=0)
            except:
                pass
            break
        except Exception as e:
            log("MQTT connect EXC:", e, "Retrying in 1.5sec...")
            time.sleep_ms(1500)

def main():
    # 1) WiFi
    try:
        wifi_connect()
    except Exception as e:
        log("WiFi error:", e)
        time.sleep(3)
        machine.reset()

    # 2) MQTT
    client = make_client()
    mqtt_connect_and_subscribe(client)

    # Start-up pulse
    blink(2, 80, 120)

    last_ping = time.ticks_ms()

    # 3) Main loop
    while True:
        try:
            # Processes incoming messages
            client.check_msg()
            # Keep the connection alive
            if time.ticks_diff(time.ticks_ms(), last_ping) > (KEEPALIVE * 500):
                try:
                    client.ping()
                    log("Ping")
                except Exception as e:
                    log("Ping EXC:", e)
                last_ping = time.ticks_ms()
            time.sleep_ms(50)

        except OSError as e:
            # Common socket errors -> full retry
            log("Loop OSError:", e, "â€” reconectando...")
            try:
                wifi_connect()
            except Exception as e2:
                log("WiFi reconnection failure:", e2)
            try:
                client = make_client()
                mqtt_connect_and_subscribe(client)
            except Exception as e3:
                log("MQTT reconnection failure:", e3)
                time.sleep_ms(1500)

        except Exception as e:
            log("Loop EXC:", e)
            time.sleep_ms(500)

# Start-up
if __name__ == "__main__":
    main()
